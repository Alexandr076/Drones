# и эти точки относительно oX
for (i in 1:N) {
buildingInfo$x1[i] <<- M$x1[i]
buildingInfo$y1[i] <<- M$y1[i]
buildingInfo$x2[i] <<- M$x2[i]
buildingInfo$y2[i] <<- M$y2[i]
listWithInfoAboutAngle <- edit_angle(APPoint$x, APPoint$y, M$x1[i], M$y1[i])
buildingInfo$fiF[i] <<- listWithInfoAboutAngle$angle
listWithInfoAboutAngle <- edit_angle(APPoint$x, APPoint$y, M$x2[i], M$y2[i])
buildingInfo$fiS[i] <<- listWithInfoAboutAngle$angle
}
}
# функция проверки, что точка лежит за пределами здания (проверка на fi). На вход подается номер UP
# точки и номер здания. Если пересечение между двумя прямыми, построенными между точками (AP,UP) и
# прямой здания существует, то записывается координата пересечения, иначе - false
VerificationUP <- function(n, N) {
coordinates <- line.line.intersection(c(APPoint$x,APPoint$y), c(coordinatesForUP$x[n],
coordinatesForUP$y[n]), c(buildingInfo$x1[N],buildingInfo$y1[N]),
c(buildingInfo$x2[N],buildingInfo$y2[N]), interior.only = "true")
coordinatesForUP$l[n] <<- pointDistance(c(APPoint$x,APPoint$y),
c(coordinatesForUP$x[n],coordinatesForUP$y[n]),
lonlat = FALSE)
if (typeof(coordinates) != "logical") {
# координаты точки пересечения и просчет длин l, l1, l2, проставление флага
coordinatesForUP$flag[n] <<- "TRUE"
coordinatesForUP$xInter[n] <<- coordinates[1]
coordinatesForUP$yInter[n] <<- coordinates[2]
coordinatesForUP$l1[n] <<- pointDistance(c(APPoint$x,APPoint$y),
c(coordinatesForUP$xInter[n],coordinatesForUP$yInter[n]),
lonlat = FALSE)
coordinatesForUP$l2[n] <<- pointDistance(c(coordinatesForUP$xInter[n],coordinatesForUP$yInter[n]),
c(coordinatesForUP$x[n],coordinatesForUP$y[n]),
lonlat = FALSE)
}
}
# функция для проверки LOS без учета максимального действия AP (true - если заблокировано)
IsLOS <- function(i, k) {
tgAlpha <- (HTx[k] - coordinatesForUP$H[i])/coordinatesForUP$l[i]
H_res <- tgAlpha*coordinatesForUP$l2[i] + coordinatesForUP$H[i]
if ( H_res > H ) {
return(FALSE)
}
else {
return(TRUE)
}
}
# функция для проверки расстояние от AP До UP (true - если незаблокирован)
IsLOSWithoutBuilding <- function(i, k) {
d <- sqrt( (HTx[k] - coordinatesForUP$H[i])^2 + (coordinatesForUP$l[i])^2 )
if ( d < R) {
return(TRUE)
}
else {
return(FALSE)
}
}
}
{
# глобалы:
# n - количество разыгрываемых точек для UP.
# N - количество построек (зданий)
# APPoint - координаты для начальной точки {x, y}
# buildingInfo - информационный фрейм об объектах
# coordinatesForUP - фрейм для хранения координат пользовательских устройств
# рандомной высотой, флагом (FALSE по умолчанию) и координатами точки пересечения
# coordinatesForUPWithTrueFlag - тоже самое, что и (выше), но с флагом = TRUE (заблокирован)
# UPblockingInfo - информация о зданиях, блокирующих i-й пользовательский девайс
# (в долгосрочной перспективе)
# gridSize - размер сетки
# R - радиус действия AP
# H - высота (для зданий и UP)
# HTx - высотка передатчика
# w - угол в плоскости YoZ между Tx и Rx
# D - расстояние между Tx и Rx в плоскости XoY
# l - расстояние между точкой пересечения прямой здания и точкой Tx в плоскости YoZ
# pConnect - вероятность los
# NumberOfIteration - количество итераций
# R - дальность действия передатчика
R <<- 100
NumberOfIteration <- 20
APPoint <<- data.frame(x = 90, y = 50.5)
H <<- 30  # build
N <<- 1
n <<- 10000
# не глобал, но определяет минимальную и максимальную высоту передатчика
HTxMin <- 45
HTxMax <- 75
gridSize <<- data.frame(x = 100, y = 100)
coordinatesForUP <<- data.frame(x = array(NA,n), y = array(NA,n),
H = 2, flag = array(FALSE, n), xInter = array(NA, n),
yInter = array(NA,n), l = array(NA, n), l1 = array(NA, n), l2 = array(NA, n))
# много точек для вывода площади
for (i in 1:100) {
for (j in 1:100) {
coordinatesForUP[((i-1)*100+j),2] <- j
}
coordinatesForUP[((i-1)*100+1):(i*100),1] <- i
}
# кэш
# coordinatesForUP <<- data.frame(x = 6, y = 8,
#                                 H = 1, flag = array(FALSE, n), xInter = array(NA, n),
#                                 yInter = array(NA,n), l = array(NA, n), l1 = array(NA, n), l2 = array(NA, n))
buildingInfo <<- data.frame(fiF = array(NA, N), fiS = array(NA, N), x1 = array(NA, N), y1 = array(NA, N),
x2 = array(NA, N), y2 = array(NA, N), H = H)
pDisconnect <<- array(NA, NumberOfIteration)
pConnect <<- array(NA, NumberOfIteration)
S <<- array(NA, NumberOfIteration)
coordinatesForUP$x <- coordinatesForUP$x
coordinatesForUP$y <- coordinatesForUP$y
coordinatesForUPCache <<- coordinatesForUP
AllPointWithLOSInCicle <<- array(NA, NumberOfIteration)
AllBlockages <<- array(NA, NumberOfIteration)
}
for (k in 1:NumberOfIteration) {
coordinatesForUP <<- coordinatesForUPCache
# coordinatesForUP[,"x"] <- runif(n, 0, gridSize$x)
# coordinatesForUP[,"y"] <- runif(n, 0, gridSize$y)
HTx <<- seq(HTxMin, HTxMax, (HTxMax - HTxMin) / (NumberOfIteration - 1))
# main
# инициация постройки зданий с общей информацией
PointsForBuilding(N)
# по всем точкам UP (1:n) проверка для каждого здания (1:N), что есть пересечение отрезка здания и {AP,UP}
for (i in 1:n) {
for (j in 1:N) {
VerificationUP(i, j)
}
}
# количество заблокированных UP
blockCountAll <- length(coordinatesForUP[coordinatesForUP[,"flag"] == TRUE,1])
# координаты для UP с флагом true
# coordinatesForUPWithTrueFlag <<- coordinatesForUP[coordinatesForUP[,"flag"] == TRUE,]
# для каждой заблокированной точки вычисляем H и исправляем флаг, если нужно
M <<- 0
Blockage <<- 0
AllPointWithLOSInCicle <<- 0
for (i in 1:length(coordinatesForUP[,1])) {
# if (IsLOSWithoutBuilding(i, k) == TRUE) {
#   PointsWithLOSInCicle <- PointsWithLOSInCicle + 1
# }
if ( (coordinatesForUP$flag[i] == TRUE)  && (IsLOSWithoutBuilding(i, k) == TRUE) && (IsLOS(i, k) == TRUE) )
{
Blockage <- Blockage + 1
}
if ( (coordinatesForUP$flag[i] == TRUE) && IsLOS(i, k) == FALSE) {
coordinatesForUP$flag[i] <- FALSE
if (IsLOSWithoutBuilding(i, k) == FALSE) {
coordinatesForUP$flag[i] <- TRUE
}
else {
M <- M + 1
}
}
if ( (coordinatesForUP$flag[i] == FALSE) && (IsLOSWithoutBuilding(i, k) == FALSE) ) {
coordinatesForUP$flag[i] <- TRUE
}
}
# количество незаблокированных UP в пространстве
# AllPointWithLOSInCicle[k] <- PointsWithLOSInCicle
NonBlocks <- M
# вычисляем вероятность успешного коннекта
pDisconnect[k] <- length(coordinatesForUP[coordinatesForUP[,"flag"] == TRUE,1])/n
pConnect[k] <- 1 - pDisconnect[k]
S[k] <- NonBlocks
AllBlockages[k] <- Blockage
# графики
# if (k %% 12 == 0) {
# plot(APPoint$x, APPoint$y, xlim = c(0,100), ylim = c(0,100), col = "black", pch = 19, xlab = 'x', ylab = 'y')
# lines(x = c(buildingInfo$x1[1],buildingInfo$x2[1]), y = c(buildingInfo$y1[1],buildingInfo$y2[1]))
# lines(x = c(buildingInfo$x1[2],buildingInfo$x2[2]), y = c(buildingInfo$y1[2],buildingInfo$y2[2]))
# lines(x = c(buildingInfo$x1[3],buildingInfo$x2[3]), y = c(buildingInfo$y1[3],buildingInfo$y2[3]))
# lines(x = c(buildingInfo$x1[4],buildingInfo$x2[4]), y = c(buildingInfo$y1[4],buildingInfo$y2[4]))
# lines(x = c(buildingInfo$x1[5],buildingInfo$x2[5]), y = c(buildingInfo$y1[5],buildingInfo$y2[5]))
# points(coordinatesForUP$x[coordinatesForUP[,"flag"] == TRUE],
#        coordinatesForUP$y[coordinatesForUP[,"flag"] == TRUE], pch = 19, col = "red")
# points(coordinatesForUP$x[coordinatesForUP[,"flag"] == FALSE],
#        coordinatesForUP$y[coordinatesForUP[,"flag"] == FALSE], pch = 19, col = "green")
# }
}
AllBlockages
PBlockage <- AllBlockages/3.141592*HTx
dataP <- smooth.spline(HTx, PBlockage, spar = 0.5)
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь S'[gain]))
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'))
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'), lwd = 2, col = 'red')
PBlockage <- AllBlockages/(3.141592*HTx)
dataP <- smooth.spline(HTx, PBlockage, spar = 0.5)
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'), lwd = 2, col = 'red')
PBlockage <- AllBlockages/(3.141592*sqrt(R^2 - (HTx - 2)^2))
dataP <- smooth.spline(HTx, PBlockage, spar = 0.5)
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'), lwd = 2, col = 'red')
HTx
PBlockage <- AllBlockages/(3.141592*(sqrt(R^2 - (HTx - 2)^2))^2)
dataP <- smooth.spline(HTx, PBlockage, spar = 0.5)
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'), lwd = 2, col = 'red')
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Вероятность блокировки зданием'), lwd = 2, col = 'red')
N <- 5
mass <- data.frame(x1 = array(NA, N), y1 = array(NA, N), x2 = array(NA, N), y2 = array(NA, N))
mass$x1[1] = 7*2.5
mass$y1[1] = 15*2.5
mass$x2[1] = 9*2.5
mass$y2[1] = 20*2.5
mass$x1[2] = 1*2.5
mass$y1[2] = 25*2.5
mass$x2[2] = 15*2.5
mass$y2[2] = 35*2.5
mass$x1[3] = 30*2.5
mass$y1[3] = 2*2.5
mass$x2[3] = 33*2.5
mass$y2[3] = 30*2.5
mass$x1[4] = 10*2.5
mass$y1[4] = 10*2.5
mass$x2[4] = 25*2.5
mass$y2[4] = 5*2.5
mass$x1[5] = 20*2.5
mass$y1[5] = 32*2.5
mass$x2[5] = 30*2.5
mass$y2[5] = 30*2.5
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]))
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]))
lines(x = c(mass$x1[4],mass$x2[4]), y = c(mass$y1[4],mass$y2[4]))
lines(x = c(mass$x1[5],mass$x2[5]), y = c(mass$y1[5],mass$y2[5]))
#lines(x = c(20,40), y = c(70,80))
lines(x=c(50,20), y=c(50,80), col = 'red')
points(20,80, pch = 19, col = 'red')
text(24,82, labels = expression('l'[m]), cex = 2)
text(30,60, labels = expression('l'[all]), cex = 2)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]))
mass$x1[1] = 25 + 2.1213
mass$y1[1] = 50 + 2.1213
mass$x2[1] = 25 - 2.1213
mass$y2[1] = 50 - 2.1213
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
mass$x1[2] = -100
mass$y1[2] = 50 - 2.1213
mass$x2[2] = 100
mass$y2[2] = 50 - 2.1213
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]))
help(lines)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), type = 'b')
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), type = 'l')
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), type = 'b')
mass$x1[2] = -100
mass$y1[2] = 50 - 2.1213
mass$x2[2] = 200
mass$y2[2] = 50 - 2.1213
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), pch = 10)
help(lines)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), cex = 10)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), cex = 10)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), cex = 1)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), cex = 1)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), cex = 20)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]))
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 2)
mass$x1[1] = 25 + 2.1213*3
mass$y1[1] = 50 + 2.1213*3
mass$x2[1] = 25 - 2.1213*3
mass$y2[1] = 50 - 2.1213*3
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 2)
mass$x1[2] = -100
mass$y1[2] = 50 - 2.1213*3
mass$x2[2] = 200
mass$y2[2] = 50 - 2.1213*3
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
mass$x1[2] = 25
mass$y1[2] = 50
mass$x2[2] = 25
mass$y2[2] = 50
mass$x2[2] = 50
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]))
mass$x1[1] = 25 + 2.1213*3
mass$y1[1] = 50 + 2.1213*3
mass$x2[1] = 25 - 2.1213*3
mass$y2[1] = 50 - 2.1213*3
mass$x1[2] = -100
mass$y1[2] = 50 - 2.1213*3
mass$x2[2] = 200
mass$y2[2] = 50 - 2.1213*3
mass$x1[3] = 25
mass$y1[3] = 50
mass$x2[3] = 50
mass$y2[3] = 50
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 2)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]))
text(40,55, labels = expression('l'[m]), cex = 2)
mass$x1[1] = 25 + 2.1213*3
mass$y1[1] = 50 + 2.1213*3
mass$x2[1] = 25 - 2.1213*3
mass$y2[1] = 50 - 2.1213*3
mass$x1[2] = -100
mass$y1[2] = 50 - 2.1213*3
mass$x2[2] = 200
mass$y2[2] = 50 - 2.1213*3
mass$x1[3] = 25
mass$y1[3] = 50
mass$x2[3] = 50
mass$y2[3] = 50
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 2)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]))
text(40,55, labels = expression('d'[x]), cex = 2)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 2)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]))
text(40,55, labels = expression('d'[x]), cex = 2)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 2)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]))
text(40,55, labels = expression('d'[x]), cex = 2)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 3)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]), lty = 15)
plot(-100,-100, xlim = c(0,100), ylim = c(0,100), xlab  = 'x', ylab = 'y')
#grid(nx=100, ny=100, lty= 1)
points(50,50, pch = 19)
lines(x = c(mass$x1[1],mass$x2[1]), y = c(mass$y1[1],mass$y2[1]), lwd = 3)
lines(x = c(mass$x1[2],mass$x2[2]), y = c(mass$y1[2],mass$y2[2]), lty = 20)
lines(x = c(mass$x1[3],mass$x2[3]), y = c(mass$y1[3],mass$y2[3]), lty = 15)
text(40,55, labels = expression('d'[x]), cex = 2)
plot(pConnect)
save.image("C:/Users/alexa/Desktop/Учеба/ВКР магистра/RdataNew.RData")
load("C:/Users/alexa/Desktop/Учеба/ВКР магистра/.RData")
load("C:/R/Drones/figure square to hight/.RData")
plot(pConnect)
AllBlockages
load("C:/Users/alexa/Desktop/Учеба/ВКР магистра/RdataNew.RData")
AllBlockages
dataP$y
AllBlockages
install.packages('methods')
install.packages("methods")
install.packages("methods")
install.packages("methods")
dataP
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
plot(HTx, datat$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
datat <- smooth.spline(HTx, S, spar = 0.5)
plot(datat,type ='l', xlab = 'Высота, м', ylab = expression('Площадь S'[gain]))
AllBlockages
S
AllBlockages
PBlockage
M
S
PBlockage <- M/(3.141592*(sqrt(R^2 - (HTx - 2)^2))^2)
dataP <- smooth.spline(HTx, PBlockage, spar = 0.5)
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'), lwd = 2, col = 'red')
newHTx <- HTx - 2
RProjection <- sqrt(100^2-newHTx^2)
SAll <- 3.141592*RProjection^2
plot(S)
plot(S/SAll)
PNonBlockage <- S/SAll
dataP <- smooth.spline(HTx, PNonBlockage, spar = 0.5)
ggg <-
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid()
help(grid)
grid(lty = 1, lwd = 1)
grid(5, 0.001,lty = 1, lwd = 1)
grid(0.001, 5, lty = 1, lwd = 1)
ggg <-
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(0.001, 5, lty = 1, lwd = 1)
grid(nx = 5, 5, lty = 1, lwd = 1)
grid(nx = 45, 5, lty = 1, lwd = 1)
grid(nx = 1, 5, lty = 1, lwd = 1)
grid(nx = 10, 5, lty = 1, lwd = 1)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = 10, 5, lty = 1, lwd = 1)
grid(nx = NULL, 5, lty = 1, lwd = 1)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, 5, lty = 1, lwd = 1)
grid(nx = NULL, 0.001, lty = 1, lwd = 1)
grid(nx = NULL, ny = 10, lty = 1, lwd = 1)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, ny = 9, lty = 1, lwd = 1)
grid(nx = NULL, , lty = 1, lwd = 1)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, , lty = 1, lwd = 1)
grid(nx = NULL, , lty = 1, lwd = 2)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, , lty = 1, lwd = 1.5)
grid(nx = NULL, , lty = 1, lwd = 1.8)
grid(nx = NULL, , lty = 1, lwd = 1.9)
grid(nx = NULL, , lty = 1, lwd = 2)
grid(nx = NULL, , lty = 2, lwd = 1)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, , lty = 2, lwd = 1)
grid(nx = NULL, , lty = 1, lwd = 1)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, , lty = 1)
grid(nx = NULL, , lty = 1, lwd = 2)
grid(nx = NULL, , lty = 1, lwd = 2)
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
grid(nx = NULL, , lty = 1, lwd = 2)
lines(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
dataP$y
PNonBlockage
dataP$y
plot(pConnect)
load("C:/Users/alexa/Desktop/Учеба/ВКР магистра/RdataNew.RData")
plot(pConnect)
load("C:/Users/alexa/Desktop/Учеба/ВКР магистра/.RData")
plot(pConnect)
plot(pConnect)
library("retistruct")
library("raster")
library("raster")
library("spatstat")
library("spatstat")
load("C:/Users/alexa/Desktop/Учеба/ВКР магистра/.RData")
load("C:/Users/alexa/Desktop/Учеба/ВКР магистра/RdataNew.RData")
dataP$y
grid(nx = NULL, , lty = 1, lwd = 2)
lines(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
PNonBlockage <- S/SAll
newHTx <- HTx - 2
RProjection <- sqrt(100^2-newHTx^2)
SAll <- 3.141592*RProjection^2
PNonBlockage <- S/SAll
dataP <- smooth.spline(HTx, PNonBlockage, spar = 0.5)
plot(dataP,type ='l', xlab = 'Высота, м', ylab = expression('Площадь "теневой" области'), lwd = 2, col = 'red')
plot(HTx, dataP$y, type ='l', col = 'red', lwd = 2, xlab = 'Высота точки доступа, м',
ylab = 'Вероятность подключения за зданием')
dataP$y
write.csv(dataP$y, file = 'newdata.csv')
getwd()
shiny::runApp('C:/R/Drones/maps')
source('function.R')
source('functions.R')
source('functions.R')
setwd('C:/R/Drones/maps')
source('functions.R')
runApp()
runApp()
runApp()
